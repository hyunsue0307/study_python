from collections.abc import Callable, Sequence
from typing import (
    Any,
    TypeAlias,
<<<<<<< HEAD
    overload,
    TypeVar,
=======
    TypeVar,
    overload,
)
from typing import (
>>>>>>> 0a20124 (readme 수정)
    Literal as L,
)

import numpy as np
from numpy import (
<<<<<<< HEAD
    generic,
    timedelta64,
    datetime64,
    int_,
    intp,
    float64,
    complex128,
    signedinteger,
    floating,
    complexfloating,
    object_,
    _OrderCF,
)

from numpy._typing import (
    DTypeLike,
    _DTypeLike,
    ArrayLike,
    _ArrayLike,
    NDArray,
    _SupportsArray,
    _SupportsArrayFunc,
    _ArrayLikeInt_co,
    _ArrayLikeFloat_co,
    _ArrayLikeComplex_co,
    _ArrayLikeObject_co,
=======
    _OrderCF,
    complex128,
    complexfloating,
    datetime64,
    float64,
    floating,
    generic,
    int_,
    intp,
    object_,
    signedinteger,
    timedelta64,
)
from numpy._typing import (
    ArrayLike,
    DTypeLike,
    NDArray,
    _ArrayLike,
    _ArrayLikeComplex_co,
    _ArrayLikeFloat_co,
    _ArrayLikeInt_co,
    _ArrayLikeObject_co,
    _DTypeLike,
    _SupportsArray,
    _SupportsArrayFunc,
>>>>>>> 0a20124 (readme 수정)
)

__all__ = [
    "diag",
    "diagflat",
    "eye",
    "fliplr",
    "flipud",
    "tri",
    "triu",
    "tril",
    "vander",
    "histogram2d",
    "mask_indices",
    "tril_indices",
    "tril_indices_from",
    "triu_indices",
    "triu_indices_from",
]

###

_T = TypeVar("_T")
<<<<<<< HEAD
_SCT = TypeVar("_SCT", bound=generic)
_SCT_complex = TypeVar("_SCT_complex", bound=np.complexfloating)
_SCT_inexact = TypeVar("_SCT_inexact", bound=np.inexact)
_SCT_number_co = TypeVar("_SCT_number_co", bound=_Number_co)
=======
_ScalarT = TypeVar("_ScalarT", bound=generic)
_ComplexFloatingT = TypeVar("_ComplexFloatingT", bound=np.complexfloating)
_InexactT = TypeVar("_InexactT", bound=np.inexact)
_NumberCoT = TypeVar("_NumberCoT", bound=_Number_co)
>>>>>>> 0a20124 (readme 수정)

# The returned arrays dtype must be compatible with `np.equal`
_MaskFunc: TypeAlias = Callable[[NDArray[int_], _T], NDArray[_Number_co | timedelta64 | datetime64 | object_]]

_Int_co: TypeAlias = np.integer | np.bool
_Float_co: TypeAlias = np.floating | _Int_co
_Number_co: TypeAlias = np.number | np.bool

<<<<<<< HEAD
_ArrayLike1D: TypeAlias = _SupportsArray[np.dtype[_SCT]] | Sequence[_SCT]
=======
_ArrayLike1D: TypeAlias = _SupportsArray[np.dtype[_ScalarT]] | Sequence[_ScalarT]
>>>>>>> 0a20124 (readme 수정)
_ArrayLike1DInt_co: TypeAlias = _SupportsArray[np.dtype[_Int_co]] | Sequence[int | _Int_co]
_ArrayLike1DFloat_co: TypeAlias = _SupportsArray[np.dtype[_Float_co]] | Sequence[float | _Float_co]
_ArrayLike2DFloat_co: TypeAlias = _SupportsArray[np.dtype[_Float_co]] | Sequence[_ArrayLike1DFloat_co]
_ArrayLike1DNumber_co: TypeAlias = _SupportsArray[np.dtype[_Number_co]] | Sequence[complex | _Number_co]

###

@overload
<<<<<<< HEAD
def fliplr(m: _ArrayLike[_SCT]) -> NDArray[_SCT]: ...
=======
def fliplr(m: _ArrayLike[_ScalarT]) -> NDArray[_ScalarT]: ...
>>>>>>> 0a20124 (readme 수정)
@overload
def fliplr(m: ArrayLike) -> NDArray[Any]: ...

@overload
<<<<<<< HEAD
def flipud(m: _ArrayLike[_SCT]) -> NDArray[_SCT]: ...
=======
def flipud(m: _ArrayLike[_ScalarT]) -> NDArray[_ScalarT]: ...
>>>>>>> 0a20124 (readme 수정)
@overload
def flipud(m: ArrayLike) -> NDArray[Any]: ...

@overload
def eye(
    N: int,
<<<<<<< HEAD
    M: None | int = ...,
=======
    M: int | None = ...,
>>>>>>> 0a20124 (readme 수정)
    k: int = ...,
    dtype: None = ...,
    order: _OrderCF = ...,
    *,
<<<<<<< HEAD
    device: None | L["cpu"] = ...,
    like: None | _SupportsArrayFunc = ...,
=======
    device: L["cpu"] | None = ...,
    like: _SupportsArrayFunc | None = ...,
>>>>>>> 0a20124 (readme 수정)
) -> NDArray[float64]: ...
@overload
def eye(
    N: int,
<<<<<<< HEAD
    M: None | int,
    k: int,
    dtype: _DTypeLike[_SCT],
    order: _OrderCF = ...,
    *,
    device: None | L["cpu"] = ...,
    like: None | _SupportsArrayFunc = ...,
) -> NDArray[_SCT]: ...
@overload
def eye(
    N: int,
    M: None | int = ...,
    k: int = ...,
    *,
    dtype: _DTypeLike[_SCT],
    order: _OrderCF = ...,
    device: None | L["cpu"] = ...,
    like: None | _SupportsArrayFunc = ...,
) -> NDArray[_SCT]: ...
@overload
def eye(
    N: int,
    M: None | int = ...,
=======
    M: int | None,
    k: int,
    dtype: _DTypeLike[_ScalarT],
    order: _OrderCF = ...,
    *,
    device: L["cpu"] | None = ...,
    like: _SupportsArrayFunc | None = ...,
) -> NDArray[_ScalarT]: ...
@overload
def eye(
    N: int,
    M: int | None = ...,
    k: int = ...,
    *,
    dtype: _DTypeLike[_ScalarT],
    order: _OrderCF = ...,
    device: L["cpu"] | None = ...,
    like: _SupportsArrayFunc | None = ...,
) -> NDArray[_ScalarT]: ...
@overload
def eye(
    N: int,
    M: int | None = ...,
>>>>>>> 0a20124 (readme 수정)
    k: int = ...,
    dtype: DTypeLike = ...,
    order: _OrderCF = ...,
    *,
<<<<<<< HEAD
    device: None | L["cpu"] = ...,
    like: None | _SupportsArrayFunc = ...,
) -> NDArray[Any]: ...

@overload
def diag(v: _ArrayLike[_SCT], k: int = ...) -> NDArray[_SCT]: ...
=======
    device: L["cpu"] | None = ...,
    like: _SupportsArrayFunc | None = ...,
) -> NDArray[Any]: ...

@overload
def diag(v: _ArrayLike[_ScalarT], k: int = ...) -> NDArray[_ScalarT]: ...
>>>>>>> 0a20124 (readme 수정)
@overload
def diag(v: ArrayLike, k: int = ...) -> NDArray[Any]: ...

@overload
<<<<<<< HEAD
def diagflat(v: _ArrayLike[_SCT], k: int = ...) -> NDArray[_SCT]: ...
=======
def diagflat(v: _ArrayLike[_ScalarT], k: int = ...) -> NDArray[_ScalarT]: ...
>>>>>>> 0a20124 (readme 수정)
@overload
def diagflat(v: ArrayLike, k: int = ...) -> NDArray[Any]: ...

@overload
def tri(
    N: int,
<<<<<<< HEAD
    M: None | int = ...,
    k: int = ...,
    dtype: None = ...,
    *,
    like: None | _SupportsArrayFunc = ...
=======
    M: int | None = ...,
    k: int = ...,
    dtype: None = ...,
    *,
    like: _SupportsArrayFunc | None = ...
>>>>>>> 0a20124 (readme 수정)
) -> NDArray[float64]: ...
@overload
def tri(
    N: int,
<<<<<<< HEAD
    M: None | int,
    k: int,
    dtype: _DTypeLike[_SCT],
    *,
    like: None | _SupportsArrayFunc = ...
) -> NDArray[_SCT]: ...
@overload
def tri(
    N: int,
    M: None | int = ...,
    k: int = ...,
    *,
    dtype: _DTypeLike[_SCT],
    like: None | _SupportsArrayFunc = ...
) -> NDArray[_SCT]: ...
@overload
def tri(
    N: int,
    M: None | int = ...,
    k: int = ...,
    dtype: DTypeLike = ...,
    *,
    like: None | _SupportsArrayFunc = ...
) -> NDArray[Any]: ...

@overload
def tril(m: _ArrayLike[_SCT], k: int = 0) -> NDArray[_SCT]: ...
=======
    M: int | None,
    k: int,
    dtype: _DTypeLike[_ScalarT],
    *,
    like: _SupportsArrayFunc | None = ...
) -> NDArray[_ScalarT]: ...
@overload
def tri(
    N: int,
    M: int | None = ...,
    k: int = ...,
    *,
    dtype: _DTypeLike[_ScalarT],
    like: _SupportsArrayFunc | None = ...
) -> NDArray[_ScalarT]: ...
@overload
def tri(
    N: int,
    M: int | None = ...,
    k: int = ...,
    dtype: DTypeLike = ...,
    *,
    like: _SupportsArrayFunc | None = ...
) -> NDArray[Any]: ...

@overload
def tril(m: _ArrayLike[_ScalarT], k: int = 0) -> NDArray[_ScalarT]: ...
>>>>>>> 0a20124 (readme 수정)
@overload
def tril(m: ArrayLike, k: int = 0) -> NDArray[Any]: ...

@overload
<<<<<<< HEAD
def triu(m: _ArrayLike[_SCT], k: int = 0) -> NDArray[_SCT]: ...
=======
def triu(m: _ArrayLike[_ScalarT], k: int = 0) -> NDArray[_ScalarT]: ...
>>>>>>> 0a20124 (readme 수정)
@overload
def triu(m: ArrayLike, k: int = 0) -> NDArray[Any]: ...

@overload
def vander(  # type: ignore[misc]
    x: _ArrayLikeInt_co,
<<<<<<< HEAD
    N: None | int = ...,
    increasing: bool = ...,
) -> NDArray[signedinteger[Any]]: ...
@overload
def vander(  # type: ignore[misc]
    x: _ArrayLikeFloat_co,
    N: None | int = ...,
    increasing: bool = ...,
) -> NDArray[floating[Any]]: ...
@overload
def vander(
    x: _ArrayLikeComplex_co,
    N: None | int = ...,
    increasing: bool = ...,
) -> NDArray[complexfloating[Any, Any]]: ...
@overload
def vander(
    x: _ArrayLikeObject_co,
    N: None | int = ...,
=======
    N: int | None = ...,
    increasing: bool = ...,
) -> NDArray[signedinteger]: ...
@overload
def vander(  # type: ignore[misc]
    x: _ArrayLikeFloat_co,
    N: int | None = ...,
    increasing: bool = ...,
) -> NDArray[floating]: ...
@overload
def vander(
    x: _ArrayLikeComplex_co,
    N: int | None = ...,
    increasing: bool = ...,
) -> NDArray[complexfloating]: ...
@overload
def vander(
    x: _ArrayLikeObject_co,
    N: int | None = ...,
>>>>>>> 0a20124 (readme 수정)
    increasing: bool = ...,
) -> NDArray[object_]: ...

@overload
def histogram2d(
<<<<<<< HEAD
    x: _ArrayLike1D[_SCT_complex],
    y: _ArrayLike1D[_SCT_complex | _Float_co],
    bins: int | Sequence[int] = ...,
    range: None | _ArrayLike2DFloat_co = ...,
    density: None | bool = ...,
    weights: None | _ArrayLike1DFloat_co = ...,
) -> tuple[
    NDArray[float64],
    NDArray[_SCT_complex],
    NDArray[_SCT_complex],
]: ...
@overload
def histogram2d(
    x: _ArrayLike1D[_SCT_complex | _Float_co],
    y: _ArrayLike1D[_SCT_complex],
    bins: int | Sequence[int] = ...,
    range: None | _ArrayLike2DFloat_co = ...,
    density: None | bool = ...,
    weights: None | _ArrayLike1DFloat_co = ...,
) -> tuple[
    NDArray[float64],
    NDArray[_SCT_complex],
    NDArray[_SCT_complex],
]: ...
@overload
def histogram2d(
    x: _ArrayLike1D[_SCT_inexact],
    y: _ArrayLike1D[_SCT_inexact | _Int_co],
    bins: int | Sequence[int] = ...,
    range: None | _ArrayLike2DFloat_co = ...,
    density: None | bool = ...,
    weights: None | _ArrayLike1DFloat_co = ...,
) -> tuple[
    NDArray[float64],
    NDArray[_SCT_inexact],
    NDArray[_SCT_inexact],
]: ...
@overload
def histogram2d(
    x: _ArrayLike1D[_SCT_inexact | _Int_co],
    y: _ArrayLike1D[_SCT_inexact],
    bins: int | Sequence[int] = ...,
    range: None | _ArrayLike2DFloat_co = ...,
    density: None | bool = ...,
    weights: None | _ArrayLike1DFloat_co = ...,
) -> tuple[
    NDArray[float64],
    NDArray[_SCT_inexact],
    NDArray[_SCT_inexact],
]: ...
@overload
def histogram2d(
    x: _ArrayLike1DInt_co | Sequence[float | int],
    y: _ArrayLike1DInt_co | Sequence[float | int],
    bins: int | Sequence[int] = ...,
    range: None | _ArrayLike2DFloat_co = ...,
    density: None | bool = ...,
    weights: None | _ArrayLike1DFloat_co = ...,
=======
    x: _ArrayLike1D[_ComplexFloatingT],
    y: _ArrayLike1D[_ComplexFloatingT | _Float_co],
    bins: int | Sequence[int] = ...,
    range: _ArrayLike2DFloat_co | None = ...,
    density: bool | None = ...,
    weights: _ArrayLike1DFloat_co | None = ...,
) -> tuple[
    NDArray[float64],
    NDArray[_ComplexFloatingT],
    NDArray[_ComplexFloatingT],
]: ...
@overload
def histogram2d(
    x: _ArrayLike1D[_ComplexFloatingT | _Float_co],
    y: _ArrayLike1D[_ComplexFloatingT],
    bins: int | Sequence[int] = ...,
    range: _ArrayLike2DFloat_co | None = ...,
    density: bool | None = ...,
    weights: _ArrayLike1DFloat_co | None = ...,
) -> tuple[
    NDArray[float64],
    NDArray[_ComplexFloatingT],
    NDArray[_ComplexFloatingT],
]: ...
@overload
def histogram2d(
    x: _ArrayLike1D[_InexactT],
    y: _ArrayLike1D[_InexactT | _Int_co],
    bins: int | Sequence[int] = ...,
    range: _ArrayLike2DFloat_co | None = ...,
    density: bool | None = ...,
    weights: _ArrayLike1DFloat_co | None = ...,
) -> tuple[
    NDArray[float64],
    NDArray[_InexactT],
    NDArray[_InexactT],
]: ...
@overload
def histogram2d(
    x: _ArrayLike1D[_InexactT | _Int_co],
    y: _ArrayLike1D[_InexactT],
    bins: int | Sequence[int] = ...,
    range: _ArrayLike2DFloat_co | None = ...,
    density: bool | None = ...,
    weights: _ArrayLike1DFloat_co | None = ...,
) -> tuple[
    NDArray[float64],
    NDArray[_InexactT],
    NDArray[_InexactT],
]: ...
@overload
def histogram2d(
    x: _ArrayLike1DInt_co | Sequence[float],
    y: _ArrayLike1DInt_co | Sequence[float],
    bins: int | Sequence[int] = ...,
    range: _ArrayLike2DFloat_co | None = ...,
    density: bool | None = ...,
    weights: _ArrayLike1DFloat_co | None = ...,
>>>>>>> 0a20124 (readme 수정)
) -> tuple[
    NDArray[float64],
    NDArray[float64],
    NDArray[float64],
]: ...
@overload
def histogram2d(
<<<<<<< HEAD
    x: Sequence[complex | float | int],
    y: Sequence[complex | float | int],
    bins: int | Sequence[int] = ...,
    range: None | _ArrayLike2DFloat_co = ...,
    density: None | bool = ...,
    weights: None | _ArrayLike1DFloat_co = ...,
=======
    x: Sequence[complex],
    y: Sequence[complex],
    bins: int | Sequence[int] = ...,
    range: _ArrayLike2DFloat_co | None = ...,
    density: bool | None = ...,
    weights: _ArrayLike1DFloat_co | None = ...,
>>>>>>> 0a20124 (readme 수정)
) -> tuple[
    NDArray[float64],
    NDArray[complex128 | float64],
    NDArray[complex128 | float64],
]: ...
@overload
def histogram2d(
    x: _ArrayLike1DNumber_co,
    y: _ArrayLike1DNumber_co,
<<<<<<< HEAD
    bins: _ArrayLike1D[_SCT_number_co] | Sequence[_ArrayLike1D[_SCT_number_co]],
    range: None | _ArrayLike2DFloat_co = ...,
    density: None | bool = ...,
    weights: None | _ArrayLike1DFloat_co = ...,
) -> tuple[
    NDArray[float64],
    NDArray[_SCT_number_co],
    NDArray[_SCT_number_co],
]: ...
@overload
def histogram2d(
    x: _ArrayLike1D[_SCT_inexact],
    y: _ArrayLike1D[_SCT_inexact],
    bins: Sequence[_ArrayLike1D[_SCT_number_co] | int],
    range: None | _ArrayLike2DFloat_co = ...,
    density: None | bool = ...,
    weights: None | _ArrayLike1DFloat_co = ...,
) -> tuple[
    NDArray[float64],
    NDArray[_SCT_number_co | _SCT_inexact],
    NDArray[_SCT_number_co | _SCT_inexact],
]: ...
@overload
def histogram2d(
    x: _ArrayLike1DInt_co | Sequence[float | int],
    y: _ArrayLike1DInt_co | Sequence[float | int],
    bins: Sequence[_ArrayLike1D[_SCT_number_co] | int],
    range: None | _ArrayLike2DFloat_co = ...,
    density: None | bool = ...,
    weights: None | _ArrayLike1DFloat_co = ...,
) -> tuple[
    NDArray[float64],
    NDArray[_SCT_number_co | float64],
    NDArray[_SCT_number_co | float64],
]: ...
@overload
def histogram2d(
    x: Sequence[complex | float | int],
    y: Sequence[complex | float | int],
    bins: Sequence[_ArrayLike1D[_SCT_number_co] | int],
    range: None | _ArrayLike2DFloat_co = ...,
    density: None | bool = ...,
    weights: None | _ArrayLike1DFloat_co = ...,
) -> tuple[
    NDArray[float64],
    NDArray[_SCT_number_co | complex128 | float64],
    NDArray[_SCT_number_co | complex128 | float64] ,
=======
    bins: _ArrayLike1D[_NumberCoT] | Sequence[_ArrayLike1D[_NumberCoT]],
    range: _ArrayLike2DFloat_co | None = ...,
    density: bool | None = ...,
    weights: _ArrayLike1DFloat_co | None = ...,
) -> tuple[
    NDArray[float64],
    NDArray[_NumberCoT],
    NDArray[_NumberCoT],
]: ...
@overload
def histogram2d(
    x: _ArrayLike1D[_InexactT],
    y: _ArrayLike1D[_InexactT],
    bins: Sequence[_ArrayLike1D[_NumberCoT] | int],
    range: _ArrayLike2DFloat_co | None = ...,
    density: bool | None = ...,
    weights: _ArrayLike1DFloat_co | None = ...,
) -> tuple[
    NDArray[float64],
    NDArray[_NumberCoT | _InexactT],
    NDArray[_NumberCoT | _InexactT],
]: ...
@overload
def histogram2d(
    x: _ArrayLike1DInt_co | Sequence[float],
    y: _ArrayLike1DInt_co | Sequence[float],
    bins: Sequence[_ArrayLike1D[_NumberCoT] | int],
    range: _ArrayLike2DFloat_co | None = ...,
    density: bool | None = ...,
    weights: _ArrayLike1DFloat_co | None = ...,
) -> tuple[
    NDArray[float64],
    NDArray[_NumberCoT | float64],
    NDArray[_NumberCoT | float64],
]: ...
@overload
def histogram2d(
    x: Sequence[complex],
    y: Sequence[complex],
    bins: Sequence[_ArrayLike1D[_NumberCoT] | int],
    range: _ArrayLike2DFloat_co | None = ...,
    density: bool | None = ...,
    weights: _ArrayLike1DFloat_co | None = ...,
) -> tuple[
    NDArray[float64],
    NDArray[_NumberCoT | complex128 | float64],
    NDArray[_NumberCoT | complex128 | float64],
>>>>>>> 0a20124 (readme 수정)
]: ...
@overload
def histogram2d(
    x: _ArrayLike1DNumber_co,
    y: _ArrayLike1DNumber_co,
    bins: Sequence[Sequence[bool]],
<<<<<<< HEAD
    range: None | _ArrayLike2DFloat_co = ...,
    density: None | bool = ...,
    weights: None | _ArrayLike1DFloat_co = ...,
=======
    range: _ArrayLike2DFloat_co | None = ...,
    density: bool | None = ...,
    weights: _ArrayLike1DFloat_co | None = ...,
>>>>>>> 0a20124 (readme 수정)
) -> tuple[
    NDArray[float64],
    NDArray[np.bool],
    NDArray[np.bool],
]: ...
@overload
def histogram2d(
    x: _ArrayLike1DNumber_co,
    y: _ArrayLike1DNumber_co,
<<<<<<< HEAD
    bins: Sequence[Sequence[int | bool]],
    range: None | _ArrayLike2DFloat_co = ...,
    density: None | bool = ...,
    weights: None | _ArrayLike1DFloat_co = ...,
=======
    bins: Sequence[Sequence[int]],
    range: _ArrayLike2DFloat_co | None = ...,
    density: bool | None = ...,
    weights: _ArrayLike1DFloat_co | None = ...,
>>>>>>> 0a20124 (readme 수정)
) -> tuple[
    NDArray[float64],
    NDArray[np.int_ | np.bool],
    NDArray[np.int_ | np.bool],
]: ...
@overload
def histogram2d(
    x: _ArrayLike1DNumber_co,
    y: _ArrayLike1DNumber_co,
<<<<<<< HEAD
    bins: Sequence[Sequence[float | int | bool]],
    range: None | _ArrayLike2DFloat_co = ...,
    density: None | bool = ...,
    weights: None | _ArrayLike1DFloat_co = ...,
=======
    bins: Sequence[Sequence[float]],
    range: _ArrayLike2DFloat_co | None = ...,
    density: bool | None = ...,
    weights: _ArrayLike1DFloat_co | None = ...,
>>>>>>> 0a20124 (readme 수정)
) -> tuple[
    NDArray[float64],
    NDArray[np.float64 | np.int_ | np.bool],
    NDArray[np.float64 | np.int_ | np.bool],
]: ...
@overload
def histogram2d(
    x: _ArrayLike1DNumber_co,
    y: _ArrayLike1DNumber_co,
<<<<<<< HEAD
    bins: Sequence[Sequence[complex | float | int | bool]],
    range: None | _ArrayLike2DFloat_co = ...,
    density: None | bool = ...,
    weights: None | _ArrayLike1DFloat_co = ...,
=======
    bins: Sequence[Sequence[complex]],
    range: _ArrayLike2DFloat_co | None = ...,
    density: bool | None = ...,
    weights: _ArrayLike1DFloat_co | None = ...,
>>>>>>> 0a20124 (readme 수정)
) -> tuple[
    NDArray[float64],
    NDArray[np.complex128 | np.float64 | np.int_ | np.bool],
    NDArray[np.complex128 | np.float64 | np.int_ | np.bool],
]: ...

# NOTE: we're assuming/demanding here the `mask_func` returns
# an ndarray of shape `(n, n)`; otherwise there is the possibility
# of the output tuple having more or less than 2 elements
@overload
def mask_indices(
    n: int,
    mask_func: _MaskFunc[int],
    k: int = ...,
) -> tuple[NDArray[intp], NDArray[intp]]: ...
@overload
def mask_indices(
    n: int,
    mask_func: _MaskFunc[_T],
    k: _T,
) -> tuple[NDArray[intp], NDArray[intp]]: ...

def tril_indices(
    n: int,
    k: int = ...,
<<<<<<< HEAD
    m: None | int = ...,
=======
    m: int | None = ...,
>>>>>>> 0a20124 (readme 수정)
) -> tuple[NDArray[int_], NDArray[int_]]: ...

def tril_indices_from(
    arr: NDArray[Any],
    k: int = ...,
) -> tuple[NDArray[int_], NDArray[int_]]: ...

def triu_indices(
    n: int,
    k: int = ...,
<<<<<<< HEAD
    m: None | int = ...,
=======
    m: int | None = ...,
>>>>>>> 0a20124 (readme 수정)
) -> tuple[NDArray[int_], NDArray[int_]]: ...

def triu_indices_from(
    arr: NDArray[Any],
    k: int = ...,
) -> tuple[NDArray[int_], NDArray[int_]]: ...
